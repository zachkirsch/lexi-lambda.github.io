<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Alexis King's Blog: Posts tagged 'types'</title>
  <description>Alexis King's Blog: Posts tagged 'types'</description>
  <link>http://lexi-lambda.github.io/tags/types.html</link>
  <lastBuildDate>Thu, 13 Aug 2020 13:51:57 UT</lastBuildDate>
  <pubDate>Thu, 13 Aug 2020 13:51:57 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Types as axioms, or: playing god with static types</title>
   <link>http://lexi-lambda.github.io/blog/2020/08/13/types-as-axioms-or-playing-god-with-static-types/?utm_source=types&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2020-08-13-types-as-axioms-or-playing-god-with-static-types</guid>
   <pubDate>Thu, 13 Aug 2020 13:51:57 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Just what exactly &lt;em&gt;is&lt;/em&gt; a type?&lt;/p&gt;

&lt;p&gt;A common perspective is that types are &lt;em&gt;restrictions&lt;/em&gt;. Static types restrict the set of values a variable may contain, capturing some subset of the space of “all possible values.” Under this worldview, a typechecker is sort of like an oracle, predicting which values will end up where when the program runs and making sure they satisfy the constraints the programmer wrote down in the type annotations. Of course, the typechecker can’t &lt;em&gt;really&lt;/em&gt; predict the future, so when the typechecker gets it wrong—it can’t “figure out” what a value will be—static types can feel like self-inflicted shackles.&lt;/p&gt;

&lt;p&gt;But that is not the &lt;em&gt;only&lt;/em&gt; perspective. There is another way—a way that puts you, the programmer, back in the driver’s seat. You make the rules, you call the shots, you set the objectives. You need not be limited any longer by what the designers of your programming language decided the typechecker can and cannot prove. You do not serve the typechecker; the typechecker serves &lt;em&gt;you.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;…no, I’m not trying to sell you a dubious self-help book for programmers who feel like they’ve lost control of their lives. If the above sounds too good to be true, well… I won’t pretend it’s all actually as easy as I make it sound. Nevertheless, it’s well within the reach of the working programmer, and most remarkably, all it takes is a change in perspective.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="seeing-the-types-half-empty"&gt;Seeing the types half-empty&lt;/h1&gt;

&lt;p&gt;Let’s talk a little about TypeScript.&lt;/p&gt;

&lt;p&gt;TypeScript is a &lt;em&gt;gradually-typed&lt;/em&gt; language, which means it’s possible to mix statically- and dynamically-typed code. The original intended use case of gradual typing was to &lt;em&gt;gradually&lt;/em&gt; add static types to an existing dynamically-typed codebase, which imposes some interesting design constraints. For one, a valid JavaScript program must also be a valid TypeScript program; for another, TypeScript must be accommodating of traditional JavaScript idioms.&lt;/p&gt;

&lt;p&gt;Gradually typed languages like TypeScript are particularly good illustrations of the way type annotations can be viewed as constraints. A function with no explicit type declarations&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; can accept &lt;em&gt;any&lt;/em&gt; JavaScript value, so adding a type annotation fundamentally restricts the set of legal values.&lt;/p&gt;

&lt;p&gt;Furthermore, languages like TypeScript tend to have subtyping. This makes it easy to classify certain types as “more restrictive” than others. For example, a type like &lt;code&gt;string | number&lt;/code&gt; clearly includes more values than just &lt;code&gt;number&lt;/code&gt;, so &lt;code&gt;number&lt;/code&gt; is a more restrictive type—a &lt;em&gt;subtype&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;An exceptionally concrete way to illustrate this “types are restrictions” mentality is to write a function with an unnecessarily specific type. Here’s a TypeScript function that returns the first element in an array of numbers:&lt;/p&gt;

&lt;div class="brush: typescript"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;getFirst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arr&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;undefined&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This function would work perfectly well given a list of strings, but if you write &lt;code&gt;getFirst(["hello", "world"])&lt;/code&gt;, the typechecker will complain. Of course, in this example the restriction is thoroughly self-imposed—it would be easy to give this function a generic type—but sometimes it’s not quite so easy. For example, suppose we write a function where the return type depends upon the type of the argument:&lt;/p&gt;

&lt;div class="brush: typescript"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;emptyLike&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;val&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;number&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s2"&gt;"number"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now if we write &lt;code&gt;emptyLike(42) * 10&lt;/code&gt;, the typechecker will once again complain, claiming the result could be a string—it can’t “figure out” that when we pass a number, we always get a number back.&lt;/p&gt;

&lt;p&gt;When type systems are approached from this perspective, the result is often frustration. The programmer knows that the equivalent untyped JavaScript is perfectly well-behaved, so the typechecker comes off as being the highly unfortunate combination of stubborn yet dim-witted. What’s more, the programmer likely has little mental model of the typechecker’s internal operation, so when types like the above are inferred (not explicitly written), it can be unclear what solutions exist to make the error go away.&lt;/p&gt;

&lt;p&gt;At this point, the programmer may give up. “Stupid typechecker,” they grumble, changing the return type of &lt;code&gt;emptyList&lt;/code&gt; to &lt;code&gt;any&lt;/code&gt;. “If it can’t even figure this out, can it &lt;em&gt;really&lt;/em&gt; be all that useful?”&lt;/p&gt;

&lt;p&gt;Sadly, this relationship with the typechecker is all too common, and gradually-typed languages in particular tend to create a vicious cycle of frustration:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Gradual type systems are intentionally designed to “just work” on idiomatic code as much as possible, so programmers may not think much about the types except when they get type errors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Furthermore, many programmers using gradually-typed languages are already adept at programming in the underlying dynamically-typed language, so they have working mental models of program operation in terms of the dynamic semantics alone. They are much less likely to develop a rich mental model of the static semantics of the type system because they are used to reasoning without one.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Gradually typed languages must support idioms from their dynamically-typed heritage, so they often include ad-hoc special cases (such as, for example, special treatment of &lt;code&gt;typeof&lt;/code&gt; checks) that obscure the rules the typechecker follows and make them seem semi-magical.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Builtin types are deeply blessed in the type system, strongly encouraging programmers to embrace their full flexibility, but leaving little recourse when they run up against their limits.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;All this frustration breeds a readiness to override the typechecker using casts or &lt;code&gt;any&lt;/code&gt;, which ultimately creates a self-fulfilling prophecy in which the typechecker rarely catches any interesting mistakes because it has been so routinely disabled.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The end result of all of this is a defeatist attitude that views the typechecker as a minor tooling convenience at best (i.e. a fancy autocomplete provider) or an active impediment at worst. Who can really blame them? The type system has (unintentionally of course) been designed in such a way so as to lead them into this dead end. The public perception of type systems settles into that of a strikingly literal nitpicker we endure rather than as a tool we actively leverage.&lt;/p&gt;

&lt;h1 id="taking-back-types"&gt;Taking back types&lt;/h1&gt;

&lt;p&gt;After everything I said above, it may be hard to imagine seeing types any other way. Indeed, through the lens of TypeScript, the “types are restrictions” mentality is incredibly natural, so much so that it seems self-evident. But let’s move away from TypeScript for a moment and focus on a different language, Haskell, which encourages a somewhat different perspective. If you aren’t familiar with Haskell, that’s alright—I’m going to try to keep the examples in this blog post as accessible as possible whether you’ve written any Haskell or not.&lt;/p&gt;

&lt;p&gt;Though Haskell and TypeScript are both statically-typed—and both of their type systems are fairly sophisticated—Haskell’s type system is almost completely different philosophically:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Haskell does not have subtyping,&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt; which means that every value belongs to exactly one type.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;While JavaScript is built around a small handful of flexible builtin datatypes (booleans, numbers, strings, arrays, and objects), Haskell has essentially no blessed, built-in datatypes other than numbers. Key types such as booleans, lists, and tuples are ordinary datatypes defined in the standard library, no different from types users could define.&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In particular, Haskell is built around the idea that datatypes can be defined with multiple &lt;em&gt;cases&lt;/em&gt;, and branching is done via pattern-matching (more on this shortly).&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Let’s look at a basic Haskell datatype declaration. Suppose we want to define a type that represents a season:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If you are familiar with TypeScript, this may look rather similar to a union type; if you’re familiar with a C-family language, this may remind you more of an enum. Both are on the right track: this defines a new type named &lt;code&gt;Season&lt;/code&gt; with four possible values, &lt;code&gt;Spring&lt;/code&gt;, &lt;code&gt;Summer&lt;/code&gt;, &lt;code&gt;Fall&lt;/code&gt;, and &lt;code&gt;Winter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But what exactly &lt;em&gt;are&lt;/em&gt; those values?&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;In TypeScript, we’d represent this type with a union of strings, like this:&lt;/p&gt;
  &lt;div class="brush: ts"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"spring"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"summer"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"fall"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"winter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Here, &lt;code&gt;Season&lt;/code&gt; is a type that can be one of those four strings, but nothing else.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In C, we’d represent this type with an enum, like this:&lt;/p&gt;
  &lt;div class="brush: c"&gt;
   &lt;div class="source"&gt;
    &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;SPRING&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SUMMER&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WINTER&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  &lt;p&gt;Here, &lt;code&gt;SPRING&lt;/code&gt;, &lt;code&gt;SUMMER&lt;/code&gt;, &lt;code&gt;FALL&lt;/code&gt;, and &lt;code&gt;WINTER&lt;/code&gt; are essentially defined to be global aliases for the integers &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;, and the type &lt;code&gt;enum season&lt;/code&gt; is essentially an alias for &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;So in TypeScript, the values are strings, and in C, the values are numbers. What are they in Haskell? Well… they simply &lt;em&gt;are&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The Haskell declaration invents four completely new constants out of thin air, &lt;code&gt;Spring&lt;/code&gt;, &lt;code&gt;Summer&lt;/code&gt;, &lt;code&gt;Fall&lt;/code&gt;, and &lt;code&gt;Winter&lt;/code&gt;. They aren’t aliases for numbers, nor are they symbols or strings. The compiler doesn’t expose anything about how it chooses to represent these values at runtime; that’s an implementation detail. In Haskell, &lt;code&gt;Spring&lt;/code&gt; is now a value &lt;em&gt;distinct from all other values&lt;/em&gt;, even if someone in a different module were to also use the name &lt;code&gt;Spring&lt;/code&gt;. Haskell type declarations let us play god, creating something from nothing.&lt;/p&gt;

&lt;p&gt;Since these values are totally unique, abstract constants, what can we actually do with them? The answer is one thing and &lt;em&gt;exactly&lt;/em&gt; one thing: we can branch on them. For example, we can write a function that takes a &lt;code&gt;Season&lt;/code&gt; as an argument and returns whether or not Christmas occurs during it:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;containsChristmas&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Bool&lt;/span&gt;
&lt;span class="nf"&gt;containsChristmas&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;-- southern hemisphere&lt;/span&gt;
  &lt;span class="kt"&gt;Fall&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;False&lt;/span&gt;
  &lt;span class="kt"&gt;Winter&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;True&lt;/span&gt;  &lt;span class="c1"&gt;-- northern hemisphere&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;case&lt;/code&gt; expressions are, to a first approximation, a lot like C-style &lt;code&gt;switch&lt;/code&gt; statements (though they can do a lot more than this simple example suggests). Using &lt;code&gt;case&lt;/code&gt;, we can also define conversions from our totally unique &lt;code&gt;Season&lt;/code&gt; constants to other types, if we want:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;seasonToString&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;span class="nf"&gt;seasonToString&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;season&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Spring&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"spring"&lt;/span&gt;
  &lt;span class="kt"&gt;Summer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"summer"&lt;/span&gt;
  &lt;span class="kt"&gt;Fall&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"fall"&lt;/span&gt;
  &lt;span class="kt"&gt;Winter&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"winter"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can also go the other way around, converting a &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;Season&lt;/code&gt;, but if we try, we run into a problem: what do we return for a string like, say, &lt;code&gt;"cheesecake"&lt;/code&gt;? In other languages, we might throw an error or return &lt;code&gt;null&lt;/code&gt;, but Haskell does not have &lt;code&gt;null&lt;/code&gt;, and errors are generally reserved for truly catastrophic failures. What can we do instead?&lt;/p&gt;

&lt;p&gt;A particularly naïve solution would be to create a type called &lt;code&gt;MaybeASeason&lt;/code&gt; that has two cases—it can be a valid &lt;code&gt;Season&lt;/code&gt;, or it can be &lt;code&gt;NotASeason&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;MaybeASeason&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;NotASeason&lt;/span&gt;

&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;MaybeASeason&lt;/span&gt;
&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="s"&gt;"spring"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt;
  &lt;span class="s"&gt;"summer"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt;
  &lt;span class="s"&gt;"fall"&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt;
  &lt;span class="s"&gt;"winter"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IsASeason&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt;        &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;NotASeason&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This shows a feature of Haskell datatypes that C-style enums do &lt;em&gt;not&lt;/em&gt; have: they aren’t just constants, they can contain other values. A &lt;code&gt;MaybeASeason&lt;/code&gt; can be one of five different values: &lt;code&gt;IsASeason Spring&lt;/code&gt;, &lt;code&gt;IsASeason Summer&lt;/code&gt;, &lt;code&gt;IsASeason Fall&lt;/code&gt;, &lt;code&gt;IsASeason Winter&lt;/code&gt;, or &lt;code&gt;NotASeason&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In TypeScript, we’d write &lt;code&gt;MaybeASeason&lt;/code&gt; more like this:&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;MaybeASeason&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"not-a-season"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is kind of nice, because we don’t have to wrap all our &lt;code&gt;Season&lt;/code&gt; values with &lt;code&gt;IsASeason&lt;/code&gt; like we have to do in Haskell. But remember that Haskell doesn’t have subtyping—every value must belong to exactly one type—so the Haskell code needs the &lt;code&gt;IsASeason&lt;/code&gt; wrapper to distinguish the value as a &lt;code&gt;MaybeASeason&lt;/code&gt; rather than a &lt;code&gt;Season&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, you may rightly point out that having to invent a type like &lt;code&gt;MaybeASeason&lt;/code&gt; every time we need to create a variant of a type with a failure case is absurd, so fortunately we can define a type like &lt;code&gt;MaybeASeason&lt;/code&gt; that works for &lt;em&gt;any&lt;/em&gt; underlying type. In Haskell, it looks like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This defines a generic type, where the &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;Maybe a&lt;/code&gt; is a stand-in for some other type, much like the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; in other languages. We can change our &lt;code&gt;stringToSeason&lt;/code&gt; function to use &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="kt"&gt;Season&lt;/span&gt;
&lt;span class="nf"&gt;stringToSeason&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;seasonString&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="s"&gt;"spring"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Spring&lt;/span&gt;
  &lt;span class="s"&gt;"summer"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Summer&lt;/span&gt;
  &lt;span class="s"&gt;"fall"&lt;/span&gt;   &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Fall&lt;/span&gt;
  &lt;span class="s"&gt;"winter"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="kt"&gt;Winter&lt;/span&gt;
  &lt;span class="kr"&gt;_&lt;/span&gt;        &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; gets us something a lot like nullable types, but it isn’t built into the type system, it’s just an ordinary type defined in the standard library.&lt;/p&gt;

&lt;h2 id="positive-versus-negative-space"&gt;Positive versus negative space&lt;/h2&gt;

&lt;p&gt;At this point, you may be wondering to yourself why I am talking about all of this, seeing as everything in the previous section is information you could find in a basic Haskell tutorial. But the point of this blog post is not to teach you Haskell, it’s to focus on a particular philosophical approach to modeling data.&lt;/p&gt;

&lt;p&gt;In TypeScript, when we write a type declaration like&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Season&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"summer"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"spring"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"fall"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="s2"&gt;"winter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;we are defining a type that can be one of those four strings &lt;em&gt;and nothing else&lt;/em&gt;. All the other strings that &lt;em&gt;aren’t&lt;/em&gt; one of those four make up &lt;code&gt;Season&lt;/code&gt;’s “negative space”—values that exist, but that we have intentionally excluded. In contrast, the Haskell type does not really have any “negative space” because we pulled four new values out of thin air.&lt;/p&gt;

&lt;p&gt;Of course, I suspect you don’t really buy this argument. What makes a string like &lt;code&gt;"cheesecake"&lt;/code&gt; “negative space” in TypeScript but not in Haskell? Well… nothing, really. The distinction I’m drawing here doesn’t really exist, it’s just a different perspective, and arguably a totally contrived and arbitrary one. But now that I’ve explained the premise and set up some context, let me provide a more compelling example.&lt;/p&gt;

&lt;p&gt;Suppose you are writing a TypeScript program, and you want a function that only accepts &lt;em&gt;non-empty&lt;/em&gt; arrays. What can you do? Your first instinct is that you need a way to somehow further restrict the function’s input type to exclude empty arrays. And indeed, there &lt;em&gt;is&lt;/em&gt; a trick for doing that:&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NonEmptyArray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[]];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Great! But what if the constraint was more complicated: what if you needed an array containing an even number of elements? Unfortunately, there isn’t really a trick for that one. At this point, you might start wishing the type system had support for something really fancy, like refinement types, so you could write something like this:&lt;/p&gt;

&lt;div class="brush: ts"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;EvenArray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nx"&gt;satisfies&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;length&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But TypeScript doesn’t support anything like that, so for now you’re stuck. You need a way to restrict the function’s domain in a way the type system does not have any special support for, so your conclusion might be “I guess the type system just can’t do this.” People tend to call this “running up against the limits of the type system.”&lt;/p&gt;

&lt;p&gt;But what if we took a different perspective? Recall that in Haskell, lists aren’t built-in datatypes, they’re just ordinary datatypes defined in the standard library:&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Cons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This type might be a bit confusing at first if you have not written any Haskell, since it’s &lt;em&gt;recursive&lt;/em&gt;. All of these are valid values of type &lt;code&gt;List Int&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;Nil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Cons 1 Nil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Cons 1 (Cons 2 Nil)&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;Cons 1 (Cons 2 (Cons 3 Nil))&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The recursive nature of &lt;code&gt;Cons&lt;/code&gt; is what gives our user-defined datatype the ability to hold any number of values: we can have any number of nested &lt;code&gt;Cons&lt;/code&gt;es we want before we terminate the list with a final &lt;code&gt;Nil&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we wanted to define an &lt;code&gt;EvenList&lt;/code&gt; type in Haskell, we might end up thinking along the same lines we did before, that we need some fancy type system extension so we can restrict &lt;code&gt;List&lt;/code&gt; to exclude lists with odd numbers of elements. But that’s focusing on the negative space of things we want to exclude… what if instead, we focused on the &lt;em&gt;positive&lt;/em&gt; space of things we want to &lt;em&gt;include?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;What do I mean by that? Well, we could define an entirely new type that’s just like &lt;code&gt;List&lt;/code&gt;, but we make it &lt;em&gt;impossible&lt;/em&gt; to ever include an odd number of elements:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Here are some valid values of type &lt;code&gt;EvenList Int&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;EvenNil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;EvenCons 1 2 EvenNil&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;EvenCons 1 2 (EvenCons 3 4 EvenNil)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Lo and behold, a datatype that can only ever include even numbers of elements!&lt;/p&gt;

&lt;p&gt;Now, at this point you might realize that this is kind of silly. We don’t need to invent an entirely new datatype for this! We could just create a list of pairs:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now values like &lt;code&gt;Cons (1, 2) (Cons (3, 4) Nil)&lt;/code&gt; would be valid values of type &lt;code&gt;EvenList Int&lt;/code&gt;, and we wouldn’t have to reinvent lists. But again, this is an approach based on thinking not on which values we want to exclude, but rather how to structure our data such that those illegal values aren’t even &lt;em&gt;constructible.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This is the essence of the Haskeller’s mantra, “Make illegal states unrepresentable,”&lt;/strong&gt; and sadly it is often misinterpreted. It’s much easier to think “hm, I want to make these states illegal, how can I add some post-hoc restrictions to rule them out?” And indeed, this is why refinement types really &lt;em&gt;are&lt;/em&gt; awesome, and when they’re available, by all means use them! But checking totally arbitrary properties at the type level is not tractable in general, and sometimes you need to think a little more outside the box.&lt;/p&gt;

&lt;h2 id="types-as-axiom-schemas"&gt;Types as axiom schemas&lt;/h2&gt;

&lt;p&gt;So far in this blog post, I’ve repeatedly touched upon a handful of different ideas in a few different ways:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Instead of thinking about how to &lt;em&gt;restrict&lt;/em&gt;, it can be useful to think about how to &lt;em&gt;correctly construct&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;In Haskell, datatype declarations invent new values out of thin air.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;We can represent a &lt;em&gt;lot&lt;/em&gt; of different data structures using the incredibly simple framework of “datatypes with several possibilities.”&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Independently, those ideas might not seem deeply related, but in fact, they’re all essential to the Haskell school of data modeling. I want to now explore how we can unify them into a single framework that makes this seem less magical and more like an iterative design process.&lt;/p&gt;

&lt;p&gt;In Haskell, when you define a datatype, you’re really defining a new, self-contained set of &lt;em&gt;axioms&lt;/em&gt; and &lt;em&gt;inference rules.&lt;/em&gt; That is rather abstract, so let’s make it more concrete. Consider the &lt;code&gt;List&lt;/code&gt; type again:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Cons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Viewed as an axiom schema, this type has one axiom and one inference rule:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The empty list is a list.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If you have a list, and you add an element to the beginning, the result is also a list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The axiom is &lt;code&gt;Nil&lt;/code&gt;, and the inference rule is &lt;code&gt;Cons&lt;/code&gt;. Every list&lt;sup&gt;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-definition" name="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-return"&gt;5&lt;/a&gt;&lt;/sup&gt; is constructed by starting with the axiom, &lt;code&gt;Nil&lt;/code&gt;, followed by some number of applications of the inference rule, &lt;code&gt;Cons&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can take a similar approach when designing the &lt;code&gt;EvenList&lt;/code&gt; type. The axiom is the same:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;The empty list is a list with an even number of elements.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;But our inference rule must preserve the invariant that the list always contains an even number of elements. We can do this by always adding two elements at a time:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;If you have a list with an even number of elements, and you add two elements to the beginning, the result is also a list with an even number of elements.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;This corresponds precisely to our &lt;code&gt;EvenList&lt;/code&gt; declaration:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;EvenNil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;EvenCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;EvenList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can also go through this same reasoning process to come up with a type that represents non-empty lists. That type has just one inference rule:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;If you have a list, and you add an element to the beginning, the result is a non-empty list.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;That inference rule corresponds to the following datatype:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmptyList&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;NonEmptyCons&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Of course, it’s possible to do this with much more than just lists. A particularly classic example is the constructive definition of natural numbers:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Zero is a natural number.&lt;/li&gt;
 &lt;li&gt;If you have a natural number, its successor (i.e. that number plus one) is also a natural number.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;These are two of the &lt;a href="https://en.wikipedia.org/wiki/Peano_axioms"&gt;Peano axioms&lt;/a&gt;, which can be represented in Haskell as the following datatype:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Zero&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Succ&lt;/span&gt; &lt;span class="kt"&gt;Natural&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Using this type, &lt;code&gt;Zero&lt;/code&gt; represents 0, &lt;code&gt;Succ Zero&lt;/code&gt; represents 1, &lt;code&gt;Succ (Succ Zero)&lt;/code&gt; represents 2, and so on. Just as &lt;code&gt;EvenList&lt;/code&gt; allowed us to represent any list with an even number of elements but made other values impossible to even express, this &lt;code&gt;Natural&lt;/code&gt; type allows us to represent all natural numbers, while other numbers (such as, for example, negative integers) are impossible to express.&lt;/p&gt;

&lt;p&gt;Now, of course, all this hinges on our interpretation of the values we’ve invented! We have chosen to interpret &lt;code&gt;Zero&lt;/code&gt; as &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n + 1&lt;/code&gt;, but that interpretation is not inherent to &lt;code&gt;Natural&lt;/code&gt;’s definition—it’s all in our heads! We could choose to interpret &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n - 1&lt;/code&gt; instead, in which case we would only be able to represent non-positive integers, or we could interpret &lt;code&gt;Zero&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;Succ n&lt;/code&gt; as &lt;code&gt;n * 2&lt;/code&gt;, in which case we could only represent powers of two.&lt;/p&gt;

&lt;p&gt;I find that people sometimes find this approach troubling, or at least counterintuitive. Is &lt;code&gt;Succ (Succ Zero)&lt;/code&gt; &lt;em&gt;really&lt;/em&gt; 2? It certainly doesn’t look like a number we’re used to writing. When someone thinks “I need a datatype for a number greater than or equal to zero,” they’re going to reach for the type in their programming language called &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, not think to invent a recursive datatype. And admittedly, the &lt;code&gt;Natural&lt;/code&gt; type defined here is not very practical: it’s an incredibly inefficient representation of natural numbers.&lt;/p&gt;

&lt;p&gt;But in less contrived situations, this approach &lt;em&gt;is&lt;/em&gt; practical, and in fact it’s highly useful! The quibble that an &lt;code&gt;EvenList Int&lt;/code&gt; isn’t “really” a &lt;code&gt;List Int&lt;/code&gt; is rather meaningless, seeing as our definition of &lt;code&gt;List&lt;/code&gt; was just as arbitrary. A great deal of our jobs as programmers is imbuing arbitrary symbols with meaning; at some point someone decided that the number 65 would correspond to the capital letter A, and it was no less arbitrary then.&lt;/p&gt;

&lt;p&gt;So when you have a property you want to capture in your types, take a step back and think about it for a little bit. Is there a way you can structure your data so that, no matter how you build it, the result is always a valid value? In other words, don’t try to add post-hoc restrictions to exclude bad values, &lt;strong&gt;make your datatypes correct by construction&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id="but-what-if-i-dont-write-haskell-and-other-closing-thoughts"&gt;“But what if I don’t write Haskell?” And other closing thoughts&lt;/h1&gt;

&lt;p&gt;I write Haskell for a living, and I wrote this blog post with both my coworkers and the broader Haskell community in mind, but if I had &lt;em&gt;only&lt;/em&gt; written it with those people in mind, it wouldn’t make sense to have spent so much time explaining basic Haskell. These techniques can be used in almost any statically typed programming language, though it’s certainly easier in some than others.&lt;/p&gt;

&lt;p&gt;I don’t want people to come away from this blog post with an impression that I think TypeScript is a bad language, or that I’m claiming Haskell can do things TypeScript can’t. In fact, TypeScript &lt;em&gt;can&lt;/em&gt; do all the things I’ve talked about in this blog post! As proof, here are TypeScript definitions of both &lt;code&gt;EvenList&lt;/code&gt; and &lt;code&gt;Natural&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: typescript"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;EvenList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;EvenList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Natural&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"zero"&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;succ&lt;/span&gt;: &lt;span class="kt"&gt;Natural&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;If anything, &lt;strong&gt;the real point of this blog post is that a type system does not have a well-defined list of things it “can prove” and “can’t prove.”&lt;/strong&gt; Languages like TypeScript don’t really encourage this approach to data modeling, where you restructure your values in a certain way so as to guarantee certain properties. Rather, they prefer to add increasingly sophisticated constraints and type system features that can capture the properties people want to capture without having to change their data representation.&lt;/p&gt;

&lt;p&gt;And in general, &lt;em&gt;that’s great!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Being able to reuse the same data representation is &lt;em&gt;hugely&lt;/em&gt; beneficial. Functions like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; already exist for ordinary lists/arrays, but a home-grown &lt;code&gt;EvenList&lt;/code&gt; type needs its own versions. Passing an &lt;code&gt;EvenList&lt;/code&gt; to a function that expects a list requires explicitly converting between the two. All these things have both code complexity and performance costs, and type system features that make these issues just invisibly disappear are &lt;em&gt;obviously&lt;/em&gt; a good thing.&lt;/p&gt;

&lt;p&gt;But the danger of treating the type system this way is that it means you may find yourself unsure what to do when suddenly you have a new requirement that the type system doesn’t provide built-in support for. What then? Do you start punching holes through your type system? The more you do that, the less useful the type system becomes: type systems are great at detecting how changes in one part of a codebase can impact seemingly-unrelated areas in surprising ways, but every unsafe cast or use of &lt;code&gt;any&lt;/code&gt; is a hard stop, a point past which the typechecker cannot propagate information. Do that once or twice in a leaf function, it’s okay, but do that even just a half dozen times in your application’s connective tissue, and your type system might not be able to catch those things anymore.&lt;/p&gt;

&lt;p&gt;Even if it isn’t a technique you use every day, it’s worth getting comfortable tweaking your data representation to preserve those guarantees. It’s a magical experience having the typechecker teach you things about your domain you hadn’t even considered simply because you got a type error and started thinking through why. Yes, it’s extra work, but trust me: it’s a lot more pleasant to work for your typechecker when you know exactly how much your typechecker is working for you.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Sort of. TypeScript will try to infer type annotations based on how variables and functions are used, but by default, it falls back on the dynamic, unchecked &lt;code&gt;any&lt;/code&gt; type if it can’t find a solution that makes the program typecheck. That behavior can be changed via a configuration option, but that isn’t relevant here: I’m just trying to illustrate a perspective, not make any kind of value judgment about TypeScript specifically.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;Sort of. Haskell does have a limited notion of subtyping when polymorphism is involved; for example, the type &lt;code&gt;forall a. a -&amp;gt; a&lt;/code&gt; is a subtype of the type &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt;. But Haskell does not have anything resembling inheritance (e.g. there is no common &lt;code&gt;Number&lt;/code&gt; supertype that includes both &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt;) nor does it have untagged unions (e.g. the argument to a function cannot be something like &lt;code&gt;Int | String&lt;/code&gt;, you must define a wrapper type like &lt;code&gt;data IntOrString = AnInt Int | AString String&lt;/code&gt;).&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;Lists, tuples, and strings do technically have special &lt;em&gt;syntax&lt;/em&gt;, which is built into the compiler, but there is truly nothing special about their semantics. They would work exactly the same way without the syntax, the code would just look less pretty.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;Haskell programmers will notice that this is not actually the definition of the list type, since the real list type uses special syntax, but I wanted to keep things as simple as possible for this blog post.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-definition" class="footnote-definition"&gt;
   &lt;p&gt;Ignoring infinite lists, but the fact that infinite lists are representable in Haskell is outside the scope of this blog post.&amp;nbsp;&lt;a href="#2020-08-13-types-as-axioms-or-playing-god-with-static-types-footnote-5-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>No, dynamic type systems are not inherently more open</title>
   <link>http://lexi-lambda.github.io/blog/2020/01/19/no-dynamic-type-systems-are-not-inherently-more-open/?utm_source=types&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open</guid>
   <pubDate>Sun, 19 Jan 2020 00:00:00 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Internet debates about typing disciplines continue to be plagued by a pervasive myth that dynamic type systems are inherently better at modeling “open world” domains. The argument usually goes like this: the goal of static typing is to pin everything down as much as possible, but in the real world, that just isn’t practical. Real systems should be loosely coupled and worry about data representation as little as possible, so dynamic types lead to a more robust system in the large.&lt;/p&gt;

&lt;p&gt;This story sounds compelling, but it isn’t true. The flaw is in the premise: static types are &lt;em&gt;not&lt;/em&gt; about “classifying the world” or pinning down the structure of every value in a system. The reality is that static type systems allow specifying exactly how much a component needs to know about the structure of its inputs, and conversely, how much it doesn’t. Indeed, in practice static type systems excel at processing data with only a partially-known structure, as they can be used to ensure application logic doesn’t accidentally assume too much.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="two-typing-fallacies"&gt;Two typing fallacies&lt;/h1&gt;

&lt;p&gt;I’ve wanted to write this blog post for a while, but what finally made me decide to do it were misinformed comments responding to &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;my previous blog post&lt;/a&gt;. Two comments in particular caught my eye, &lt;a href="https://www.reddit.com/r/programming/comments/dt0w63/parse_dont_validate/f6ulpsy/"&gt;the first of which was posted on /r/programming&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Strongly disagree with the post […] it promotes a fundamentally entangled and static view of the world. It assumes that we can or should theorize about what is &amp;ldquo;valid&amp;rdquo; input at the edge between the program and the world, thus introducing a strong sense of coupling through the entire software, where failure to conform to some schema will automatically crash the program.&lt;/p&gt;
 &lt;p&gt;This is touted as a feature here but imagine if the internet worked like this. A server changes their JSON output, and we need to recompile and reprogram the entire internet. This is the static view that is promoted as a feature here. […] The &amp;ldquo;parser mentality&amp;rdquo; is fundamentally rigid and global, whereas robust system design should be decentralised and leave interpretation of data to the receiver.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Given the argument being made in the blog post—that you should use precise types whenever possible—one can see where this misinterpretation comes from. How could a proxy server possibly be written in such a style, since it cannot anticipate the structure of its payloads? The commenter’s conclusion is that strict static typing is at odds with programs that don’t know the structure of their inputs ahead of time.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://news.ycombinator.com/item?id=21479933"&gt;The second comment was left on Hacker News&lt;/a&gt;, and it is significantly shorter than the first one:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;What would be the type signature of, say, Python&amp;rsquo;s &lt;code&gt;pickle.load()&lt;/code&gt;?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a different kind of argument, one that relies on the fact that the types of reflective operations may depend on runtime values, which makes them challenging to capture with static types. This argument suggests that static types limit expressiveness because they forbid such operations outright.&lt;/p&gt;

&lt;p&gt;Both these arguments are fallacious, but in order to show why, we have to make explicit an implicit claim. The two comments focus primarily on illustrating how static type systems can’t process data of an unknown shape, but they simultaneously advance an implicit belief: that dynamically typed languages &lt;em&gt;can&lt;/em&gt; process data of an unknown shape. As we’ll see, this belief is misguided; programs are not capable of processing data of a truly unknown shape regardless of typing discipline, and static type systems only make already-present assumptions explicit.&lt;/p&gt;

&lt;h1 id="you-cant-process-what-you-dont-know"&gt;You can’t process what you don’t know&lt;/h1&gt;

&lt;p&gt;The claim is simple: in a static type system, you must declare the shape of data ahead of time, but in a dynamic type system, the type can be, well, dynamic! It sounds self-evident, so much so that Rich Hickey has practically built a speaking career upon its emotional appeal. The only problem is it isn’t true.&lt;/p&gt;

&lt;p&gt;The hypothetical scenario usually goes like this. Say you have a distributed system, and services in the system emit events that can be consumed by any other service that might need them. Each event is accompanied by a payload, which listening services can use to inform further action. The payload itself is minimally-structured, schemaless data encoded using a generic interchange format such as JSON or &lt;a href="https://github.com/edn-format/edn"&gt;EDN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a simple example, a login service might emit an event like this one whenever a new user signs up:&lt;/p&gt;

&lt;div class="brush: json"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;"event_type"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"timestamp"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"2020-01-19T05:37:09Z"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;"user"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;"id"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"name"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Alyssa"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;"email"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"alyssa@example.com"&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Some downstream services might listen for these &lt;code&gt;signup&lt;/code&gt; events and take further action whenever they are emitted. For example, a transactional email service might send a welcome email whenever a new user signs up. If the service were written in JavaScript, the handler might look something like this:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;login&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;signup&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="nx"&gt;sendEmail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sb"&gt;`Welcome to Blockchain Emporium, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;!`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;break&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;But what if this service were written in Haskell instead? Being good, reality-fearing Haskell programmers who &lt;a href="/blog/2019/11/05/parse-don-t-validate/"&gt;parse, not validate&lt;/a&gt;, the Haskell code might look something like this, instead:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;Event&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
  &lt;span class="n"&gt;parseJSON&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;withObject&lt;/span&gt; &lt;span class="s"&gt;"Event"&lt;/span&gt; &lt;span class="nf"&gt;\&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
    &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"event_type"&lt;/span&gt;
    &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
      &lt;span class="s"&gt;"login"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"data"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="s"&gt;"signup"&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;.:&lt;/span&gt; &lt;span class="s"&gt;"signup"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"unknown event_type: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eventType&lt;/span&gt;

&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;instance&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Login&lt;/span&gt; &lt;span class="kt"&gt;LoginPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userId&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Success&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Signup&lt;/span&gt; &lt;span class="kt"&gt;SignupPayload&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;sendEmail&lt;/span&gt; &lt;span class="n"&gt;userEmail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"Welcome to Blockchain Emporium, "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"!"&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"could not parse event: "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It’s definitely more boilerplate, but some extra overhead for type definitions is to be expected (and is greatly exaggerated in such tiny examples), and the arguments we’re discussing aren’t about boilerplate, anyway. The &lt;em&gt;real&lt;/em&gt; problem with this version of the code, according to the Reddit comment from earlier, is that the Haskell code has to be updated whenever a service adds a new event type! A new case has to be added to the &lt;code&gt;Event&lt;/code&gt; datatype, and it must be given new parsing logic. And what about when new fields get added to the payload? What a maintenance nightmare.&lt;/p&gt;

&lt;p&gt;In comparison, the JavaScript code is much more permissive. If a new event type is added, it will just fall through the &lt;code&gt;switch&lt;/code&gt; and do nothing. If extra fields are added to the payload, the JavaScript code will just ignore them. Seems like a win for dynamic typing.&lt;/p&gt;

&lt;p&gt;Except that no, it isn’t. The only reason the statically typed program fails if we don’t update the &lt;code&gt;Event&lt;/code&gt; type is that we wrote &lt;code&gt;handleEvent&lt;/code&gt; that way. We could just have easily done the same thing in the JavaScript code, adding a default case that rejects unknown event types:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt; &lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* ... */&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nb"&gt;Error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sb"&gt;`unknown event_type: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;event_type&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We didn’t do that, since in this case it would clearly be silly. If a service receives an event it doesn’t know about, it should just ignore it. This is a case where being permissive is clearly the correct behavior, and we can easily implement that in the Haskell code too:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;fromJSON&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
  &lt;span class="cm"&gt;{- ... -}&lt;/span&gt;
  &lt;span class="kt"&gt;Error&lt;/span&gt; &lt;span class="kr"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is still in the spirit of “parse, don’t validate” because we’re still parsing the values we &lt;em&gt;do&lt;/em&gt; care about as early as possible, so we don’t fall into the double-validation trap. At no point do we take a code path that depends on a value being well-formed without first ensuring (with the help of the type system) that it is, in fact, actually well-formed. We don’t have to respond to an ill-formed value by raising an error! We just have to be explicit about ignoring it.&lt;/p&gt;

&lt;p&gt;This illustrates an important point: the &lt;code&gt;Event&lt;/code&gt; type in this Haskell code doesn’t describe “all possible events,” it describes all the events that the application cares about. Likewise, the code that parses those events’ payloads only worries about the fields the application needs, and it ignores extraneous ones. A static type system doesn’t require you eagerly write a schema for the whole universe, it simply requires you to be up front about the things you need.&lt;/p&gt;

&lt;p&gt;This turns out to have a lot of pleasant benefits even though knowledge about inputs is limited:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;It’s easy to discover the assumptions of the Haskell program just by looking at the type definitions. We know, for example, that this application doesn’t care about the &lt;code&gt;timestamp&lt;/code&gt; field, since it never appears in any of the payload types. In the dynamically-typed program, we’d have to audit every code path to see whether or not it inspects that field, which would be a lot of error-prone work!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;What’s more, it turns out the Haskell code doesn’t actually &lt;em&gt;use&lt;/em&gt; the &lt;code&gt;userId&lt;/code&gt; field inside the &lt;code&gt;SignupPayload&lt;/code&gt; type, so that type is overly conservative. If we want to ensure it isn’t actually needed (since, for example, maybe we’re phasing out providing the user ID in that payload entirely), we need only delete that record field; if the code typechecks, we can be confident it really doesn’t depend on that field.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, we neatly avoid all the gotchas related to shotgun parsing &lt;a href="/blog/2019/11/05/parse-don-t-validate/#the-danger-of-validation"&gt;mentioned in the previous blog post&lt;/a&gt;, since we still haven’t compromised on any of those principles.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;We’ve already invalidated the first half of the claim: that statically typed languages can’t deal with data where the structure isn’t completely known. Let’s now look at the other half, which states that dynamically typed languages can process data where the structure isn’t known at all. Maybe that still sounds right, but if you slow down and think about it more carefully, you’ll find it can’t be.&lt;/p&gt;

&lt;p&gt;The above JavaScript code makes all the same assumptions our Haskell code does: it assumes event payloads are JSON objects with an &lt;code&gt;event_type&lt;/code&gt; field, and it assumes &lt;code&gt;signup&lt;/code&gt; payloads include &lt;code&gt;data.user.name&lt;/code&gt; and &lt;code&gt;data.user.email&lt;/code&gt; fields. It certainly can’t do anything useful with truly unknown input! If a new event payload is added, our JavaScript code can’t magically adapt to handle it simply because it is dynamically typed. Dynamic typing just means the types of values are carried alongside them at runtime and checked as the program executes; the types are still there, and this program still implicitly relies on them being particular things.&lt;/p&gt;

&lt;h1 id="keeping-opaque-data-opaque"&gt;Keeping opaque data opaque&lt;/h1&gt;

&lt;p&gt;In the previous section, we debunked the idea that statically typed systems can’t process partially-known data, but if you have been paying close attention, you may have noticed it did not fully refute the original claim.&lt;/p&gt;

&lt;p&gt;Although we were able to handle unknown data, we always simply discarded it, which would not fly if we were trying to implement some sort of proxying. For example, suppose we have a forwarding service that broadcasts events over a public network, attaching a signature to each payload to ensure it can’t be spoofed. We might implement this in JavaScript this way:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;handleEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;signedPayload&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="nx"&gt;retransmitEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;signedPayload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, we don’t care about the structure of the payload at all (the &lt;code&gt;signature&lt;/code&gt; function just works on any valid JSON object), but we still have to preserve all the information. How could we do that in a statically typed language, since a statically-typed language would have to assign the payload a precise type?&lt;/p&gt;

&lt;p&gt;Once again, the answer involves rejecting the premise: there’s no need to give data a type that’s any more precise than the application needs. The same logic could be written in a straightforward way in Haskell:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;JSON&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="kt"&gt;Value&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"signature"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
  &lt;span class="n"&gt;retransmitEvent&lt;/span&gt; &lt;span class="n"&gt;signedPayload&lt;/span&gt;
&lt;span class="nf"&gt;handleEvent&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fail&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="s"&gt;"event payload was not an object "&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt; &lt;span class="n"&gt;payload&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;In this case, since we don’t care about the structure of the payload, we manipulate a value of type &lt;code&gt;JSON.Value&lt;/code&gt; directly. This type is extremely imprecise compared to our &lt;code&gt;Event&lt;/code&gt; type from earlier—it can hold any legal JSON value, of any shape—but in this case, we &lt;em&gt;want&lt;/em&gt; it to be imprecise.&lt;/p&gt;

&lt;p&gt;Thanks to that imprecision, the type system helped us here: it caught the fact that we’re assuming the payload is a JSON object, not some other JSON value, and it made us handle the non-object cases explicitly. In this case we chose to raise an error, but of course, as before, you could choose some other form of recovery if you wanted to. You just have to be explicit about it.&lt;/p&gt;

&lt;p&gt;Once more, note that the assumption we were forced to make explicit in Haskell is &lt;em&gt;also&lt;/em&gt; made by the JavaScript code! If our JavaScript &lt;code&gt;handleEvent&lt;/code&gt; function were called with a string rather than an object, it’s unlikely the behavior would be desirable, since an object spread on a string results in the following surprise:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="s2"&gt;"payload"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"y"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"l"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"o"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"a"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;signature&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"sig"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Oops. Once again, the parsing style of programming has helped us out, since if we didn’t “parse” the JSON value into an object by matching on the &lt;code&gt;Object&lt;/code&gt; case explicitly, our code would not compile, and if we left off the fallthrough case, we’d get a warning about inexhaustive patterns.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let’s look at one more example of this phenomenon before moving on. Suppose we’re consuming an API that returns user IDs, and suppose those IDs happen to be UUIDs. A straightforward interpretation of “parse, don’t validate” might suggest we represent user IDs in our Haskell API client using a &lt;code&gt;UUID&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UUID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, our Reddit commenter would likely take umbrage with this! Unless the API contract explicitly states that all user IDs will be UUIDs, this representation is overstepping our bounds. Although user IDs might be UUIDs today, perhaps they won’t be tomorrow, and then our code would break for no reason! Is this the fault of static type systems?&lt;/p&gt;

&lt;p&gt;Again, the answer is no. This is a case of improper data modeling, but the static type system is not at fault—it has simply been misused. The appropriate way to represent a &lt;code&gt;UserId&lt;/code&gt; is to define a new, opaque type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;newtype&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;UserId&lt;/span&gt; &lt;span class="kt"&gt;Text&lt;/span&gt;
  &lt;span class="kr"&gt;deriving&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Eq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;FromJSON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;ToJSON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unlike the type alias defined above which simply creates a new name for the existing &lt;code&gt;UUID&lt;/code&gt; type, this declaration creates a totally new &lt;code&gt;UserId&lt;/code&gt; type that is distinct from all other types, including &lt;code&gt;Text&lt;/code&gt;. If we keep the datatype’s constructor private (that is, we don’t export it from the module that defines this type), then the &lt;em&gt;only&lt;/em&gt; way to produce a &lt;code&gt;UserId&lt;/code&gt; will be to go through its &lt;code&gt;FromJSON&lt;/code&gt; parser. Dually, the only things you can do with a &lt;code&gt;UserId&lt;/code&gt; are compare it with other &lt;code&gt;UserId&lt;/code&gt;s for equality or serialize it using the &lt;code&gt;ToJSON&lt;/code&gt; instance. Nothing else is permitted: the type system will prevent you from depending on the remote service’s internal representation of user IDs.&lt;/p&gt;

&lt;p&gt;This illustrates another way that static type systems can provide strong, useful guarantees when manipulating completely opaque data. The runtime representation of a &lt;code&gt;UserId&lt;/code&gt; is really just a string, but the type system does not allow you to accidentally use it like it’s a string, nor does it allow you to forge a new &lt;code&gt;UserId&lt;/code&gt; out of thin air from an arbitrary string.&lt;sup&gt;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-definition" name="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;The type system is not a ball and chain forcing you to describe the representation of every value that enters and leaves your program in exquisite detail. Rather, it’s a tool that you can use in whatever way best suits your needs.&lt;/p&gt;

&lt;h1 id="reflection-is-not-special"&gt;Reflection is not special&lt;/h1&gt;

&lt;p&gt;We’ve now thoroughly debunked the claims made by the first commenter, but the question posed by the second commenter may still seem like a loophole in our logic. What &lt;em&gt;is&lt;/em&gt; the type of Python’s &lt;code&gt;pickle.load()&lt;/code&gt;? For those unfamiliar, &lt;a href="https://docs.python.org/3/library/pickle.html"&gt;Python’s cutely-named &lt;code&gt;pickle&lt;/code&gt; library&lt;/a&gt; allows serializing and deserializing entire Python object graphs. Any object can be serialized and stored in a file using &lt;code&gt;pickle.dump()&lt;/code&gt;, and it can be deserialized at a later point in time using &lt;code&gt;pickle.load()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What makes this appear challenging to our static type system is that the type of value produced by &lt;code&gt;pickle.load()&lt;/code&gt; is difficult to predict—it depends entirely on whatever happened to be written to that file using &lt;code&gt;pickle.dump()&lt;/code&gt;. This seems inherently dynamic, since we cannot possibly know what type of value it will produce at compile-time. At first blush, this is something a dynamically typed system can pull off, but a statically-typed one just can’t.&lt;/p&gt;

&lt;p&gt;However, it turns out this situation is actually identical to the previous examples using JSON, and the fact that Python’s pickling serializes native Python objects directly does not change things. Why? Well, consider what happens &lt;em&gt;after&lt;/em&gt; a program calls &lt;code&gt;pickle.load()&lt;/code&gt;. Say you write the following function:&lt;/p&gt;

&lt;div class="brush: python"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;load_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;# do something with `val`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The trouble is that &lt;code&gt;val&lt;/code&gt; can now be of &lt;em&gt;any&lt;/em&gt; type, and just as you can’t do anything useful with truly unknown, unstructured input, you can’t do anything with a value unless you know at least something about it. If you call any method or access any field on the result, then you’ve already made an assumption about what sort of thing &lt;code&gt;pickle.load(f)&lt;/code&gt; returned—and it turns out those assumptions &lt;em&gt;are&lt;/em&gt; &lt;code&gt;val&lt;/code&gt;’s type!&lt;/p&gt;

&lt;p&gt;For example, imagine the only thing you do with &lt;code&gt;val&lt;/code&gt; is call the &lt;code&gt;val.foo()&lt;/code&gt; method and return its result, which is expected to be a string. If we were writing Java, then the expected type of &lt;code&gt;val&lt;/code&gt; would be quite straightforward—we’d expect it to be an instance of the following interface:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And indeed, it turns out a &lt;code&gt;pickle.load()&lt;/code&gt;-like function can be given a perfectly reasonable type in Java:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;load&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Nitpickers will complain that this isn’t the same as &lt;code&gt;pickle.load()&lt;/code&gt;, since you have to pass a &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; token to choose what type of thing you want ahead of time. However, nothing is stopping you from passing &lt;code&gt;Serializable.class&lt;/code&gt; and branching on the type later, after the object has been loaded. And that’s the key point: the instant you do &lt;em&gt;anything&lt;/em&gt; with the object, you must know something about its type, even in a dynamically typed language! The statically-typed language just forces you to be more explicit about it, just as it did when we were talking about JSON payloads.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Can we do this in Haskell, too? Absolutely—we can use &lt;a href="https://hackage.haskell.org/package/serialise"&gt;the &lt;code&gt;serialise&lt;/code&gt; library&lt;/a&gt;, which has a similar API to the Java one mentioned above. It also happens to have a very similar interface to &lt;a href="https://hackage.haskell.org/package/aeson"&gt;the Haskell JSON library, aeson&lt;/a&gt;, as it turns out the problem of dealing with unknown JSON data is not terribly different from dealing with an unknown Haskell value—at some point, you have to do a little bit of parsing to do anything with the value.&lt;/p&gt;

&lt;p&gt;That said, while you &lt;em&gt;can&lt;/em&gt; emulate the dynamic typing of &lt;code&gt;pickle.load()&lt;/code&gt; if you really want to by deferring the type check until the last possible moment, the reality is that doing so is almost never actually useful. At some point, you have to make assumptions about the structure of the value in order to use it, and you know what those assumptions are because &lt;em&gt;you wrote the code&lt;/em&gt;. While there are extremely rare exceptions to this that require true dynamic code loading (such as, say, implementing a REPL for your programming language), they do not occur in day-to-day programming, and programmers in statically-typed languages are perfectly happy to supply their assumptions up front.&lt;/p&gt;

&lt;p&gt;This is one of the fundamental disconnects between the static typing camp and the dynamic typing camp. Programmers working in statically-typed languages are perplexed when a programmer suggests they can do something in a dynamically typed language that a statically-typed language “fundamentally” prevents, since a programmer in a statically-typed language may reply the value has simply not been given a sufficiently precise type. From the perspective of a programmer working in a dynamically-typed language, the type system restricts the space of legal behaviors, but from the perspective of a programmer working in a statically-typed language, the set of legal behaviors &lt;em&gt;is&lt;/em&gt; a value’s type.&lt;/p&gt;

&lt;p&gt;Neither of these perspectives are actually inaccurate, from the appropriate point of view. Static type systems &lt;em&gt;do&lt;/em&gt; impose restrictions on program structure, as it is provably impossible to reject &lt;em&gt;all&lt;/em&gt; bad programs in a Turing-complete language without also rejecting some good ones (this is &lt;a href="https://en.wikipedia.org/wiki/Rice's_theorem"&gt;Rice’s theorem&lt;/a&gt;). But it is simultaneously true that the impossibility of solving the general problem does not preclude solving a slightly more restricted version of the problem in a useful way, and a lot of the so-called “fundamental” inabilities of static type systems are not fundamental at all.&lt;/p&gt;

&lt;h1 id="appendix-the-reality-behind-the-myths"&gt;Appendix: the reality behind the myths&lt;/h1&gt;

&lt;p&gt;The key thesis of this blog post has now been delivered: static type systems are not fundamentally worse than dynamic type systems at processing data with an open or partially-known structure. The sorts of claims made in the comments cited at the beginning of this blog post are not accurate depictions of what statically-typed program construction is like, and they misunderstand the limitations of static typing disciplines while exaggerating the capabilities of dynamically typed disciplines.&lt;/p&gt;

&lt;p&gt;However, although greatly exaggerated, these myths do have some basis in reality. They appear to have developed at least in part from a misunderstanding about the differences between structural and nominal typing. This difference is unfortunately too big to address in this blog post, as it could likely fill several blog posts of its own. About six months ago I attempted to write a blog post on the subject, but I didn’t think it came out very compelling, so I scrapped it. Maybe someday I’ll find a better way to communicate the ideas.&lt;/p&gt;

&lt;p&gt;Although I can’t give it the full treatment it deserves right now, I’d still like to touch on the idea briefly so that interested readers may be able to find other resources on the subject should they wish to do so. The key idea is that many dynamically typed languages idiomatically reuse simple data structures like hashmaps to represent what in statically-typed languages are often represented by bespoke datatypes (usually defined as classes or structs).&lt;/p&gt;

&lt;p&gt;These two styles facilitate very different flavors of programming. A JavaScript or Clojure program may represent a record as a hashmap from string or symbol keys to values, written using object or hash literals and manipulated using ordinary functions from the standard library that manipulate keys and values in a generic way. This makes it straightforward to take two records and union their fields or to take an arbitrary (or even dynamic) subselection of fields from an existing record.&lt;/p&gt;

&lt;p&gt;In contrast, most static type systems do not allow such free-form manipulation of records because records are not maps at all but unique types distinct from all other types. These types are uniquely identified by their (fully-qualified) name, hence the term &lt;em&gt;nominal typing&lt;/em&gt;. If you wish to take a subselection of a struct’s fields, you must define an entirely new struct; doing this often creates an explosion of awkward boilerplate.&lt;/p&gt;

&lt;p&gt;This is one of the main ideas that Rich Hickey has discussed in many of his talks that criticize static typing. He has advanced the idea that this ability to fluidly merge, separate, and transform records makes dynamic typing particularly suited to the domain of distributed, open systems. Unfortunately, this rhetoric has two significant flaws:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;It skirts too close to calling this a fundamental limitation of type systems, suggesting that it is not simply inconvenient but &lt;em&gt;impossible&lt;/em&gt; to model such systems in a nominal, static type system. Not only is this not true (as this blog post has demonstrated), it misdirects people away from the point of his that actually has value: the practical, pragmatic advantage of a more structural approach to data modeling.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;It confuses the structural/nominal distinction with the dynamic/static distinction, incorrectly creating the impression that the fluid merging and splitting of records represented as key-value maps is only possible in a dynamically typed language. In fact, not only can statically-typed languages support structural typing, many dynamically-typed languages also support nominal typing. These axes have historically loosely correlated, but they are theoretically orthogonal.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For counterexamples to these claims, consider Python classes, which are quite nominal despite being dynamic, and TypeScript interfaces, which are structural despite being static. Indeed, modern statically-typed languages are increasingly acquiring native support for structurally-typed records. In these systems, record types work much like hashes in Clojure—they are not distinct, named types but rather anonymous collections of key-value pairs—and they support many of the same expressive manipulation operations that Clojure’s hashes do, all within a statically-typed framework.&lt;/p&gt;

&lt;p&gt;If you are interested in exploring static type systems with strong support for structural typing, I would recommend taking a look at any of TypeScript, Flow, PureScript, Elm, OCaml, or Reason, all of which have some sort of support for structurally typed records. What I would &lt;em&gt;not&lt;/em&gt; recommend for this purpose is Haskell, which has abysmal support for structural typing; Haskell is (for various reasons outside the scope of this blog post) aggressively nominal.&lt;sup&gt;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-definition" name="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Does this mean Haskell is bad, or that it cannot be practically used to solve these kinds of problems? No, certainly not; there are many ways to model these problems in Haskell that work well enough, though some of them suffer from significant boilerplate. The core thesis of this blog post applies just as much to Haskell as it does to any of the other languages I mentioned above. However, I would be remiss not to mention this distinction, as it may give programmers from a dynamically-typed background who have historically found statically-typed languages much more frustrating to work with a better understanding of the &lt;em&gt;real&lt;/em&gt; reason they feel that way. (Essentially all mainstream, statically-typed OOP languages are even more nominal than Haskell!)&lt;/p&gt;

&lt;p&gt;As closing thoughts: this blog post is not intended to start a flame war, nor is it intended to be an assault on dynamically typed programming. There are many patterns in dynamically-typed languages that are genuinely difficult to translate into a statically-typed context, and I think discussions of those patterns can be productive. The purpose of this blog post is to clarify why one particular discussion is &lt;em&gt;not&lt;/em&gt; productive, so please: stop making these arguments. There are much more productive conversations to have about typing than this.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Technically, you could abuse the &lt;code&gt;FromJSON&lt;/code&gt; instance to convert an arbitrary string to a &lt;code&gt;UserId&lt;/code&gt;, but this would not be as easy as it sounds, since &lt;code&gt;fromJSON&lt;/code&gt; can fail. This means you’d somehow have to handle that failure case, so this trick would be unlikely to get you very far unless you’re already in a context where you’re doing input parsing… at which point it would be easier to just do the right thing. So yes, the type system doesn’t prevent you from going out of your way to shoot yourself in the foot, but it guides you towards the right solution (and there is no safeguard in existence that can completely protect a programmer from making their own life miserable if they are determined to do so).&amp;nbsp;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;I consider this to be Haskell’s most significant flaw at the time of this writing.&amp;nbsp;&lt;a href="#2020-01-19-no-dynamic-type-systems-are-not-inherently-more-open-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>Parse, don’t validate</title>
   <link>http://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/?utm_source=types&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-lexi-lambda-github-io:-blog-2019-11-05-parse-don-t-validate</guid>
   <pubDate>Tue, 05 Nov 2019 17:09:58 UT</pubDate>
   <author>Alexis King</author>
   <description>
&lt;p&gt;Historically, I’ve struggled to find a concise, simple way to explain what it means to practice type-driven design. Too often, when someone asks me “How did you come up with this approach?” I find I can’t give them a satisfying answer. I know it didn’t just come to me in a vision—I have an iterative design process that doesn’t require plucking the “right” approach out of thin air—yet I haven’t been very successful in communicating that process to others.&lt;/p&gt;

&lt;p&gt;However, about a month ago, &lt;a href="https://twitter.com/lexi_lambda/status/1182242561655746560"&gt;I was reflecting on Twitter&lt;/a&gt; about the differences I experienced parsing JSON in statically- and dynamically-typed languages, and finally, I realized what I was looking for. Now I have a single, snappy slogan that encapsulates what type-driven design means to me, and better yet, it’s only three words long:&lt;/p&gt;

&lt;div style="text-align: center; font-size: larger"&gt;&lt;strong&gt;Parse, don’t validate.&lt;/strong&gt;&lt;/div&gt;
&lt;!-- more--&gt;

&lt;h1 id="the-essence-of-type-driven-design"&gt;The essence of type-driven design&lt;/h1&gt;

&lt;p&gt;Alright, I’ll confess: unless you already know what type-driven design is, my catchy slogan probably doesn’t mean all that much to you. Fortunately, that’s what the remainder of this blog post is for. I’m going to explain precisely what I mean in gory detail—but first, we need to practice a little wishful thinking.&lt;/p&gt;

&lt;h2 id="the-realm-of-possibility"&gt;The realm of possibility&lt;/h2&gt;

&lt;p&gt;One of the wonderful things about static type systems is that they can make it possible, and sometimes even easy, to answer questions like “is it possible to write this function?” For an extreme example, consider the following Haskell type signature:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;foo&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;Integer&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Void&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Is it possible to implement &lt;code&gt;foo&lt;/code&gt;? Trivially, the answer is &lt;em&gt;no&lt;/em&gt;, as &lt;code&gt;Void&lt;/code&gt; is a type that contains no values, so it’s impossible for &lt;em&gt;any&lt;/em&gt; function to produce a value of type &lt;code&gt;Void&lt;/code&gt;.&lt;sup&gt;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-1-definition" name="2019-11-05-parse-don-t-validate-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt; That example is pretty boring, but the question gets much more interesting if we choose a more realistic example:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This function returns the first element from a list. Is it possible to implement? It certainly doesn’t sound like it does anything very complicated, but if we attempt to implement it, the compiler won’t be satisfied:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘head’: Patterns not matched: []&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This message is helpfully pointing out that our function is &lt;em&gt;partial&lt;/em&gt;, which is to say it is not defined for all possible inputs. Specifically, it is not defined when the input is &lt;code&gt;[]&lt;/code&gt;, the empty list. This makes sense, as it isn’t possible to return the first element of a list if the list is empty—there’s no element to return! So, remarkably, we learn this function isn’t possible to implement, either.&lt;/p&gt;

&lt;h2 id="turning-partial-functions-total"&gt;Turning partial functions total&lt;/h2&gt;

&lt;p&gt;To someone coming from a dynamically-typed background, this might seem perplexing. If we have a list, we might very well want to get the first element in it. And indeed, the operation of “getting the first element of a list” isn’t impossible in Haskell, it just requires a little extra ceremony. There are two different ways to fix the &lt;code&gt;head&lt;/code&gt; function, and we’ll start with the simplest one.&lt;/p&gt;

&lt;h3 id="managing-expectations"&gt;Managing expectations&lt;/h3&gt;

&lt;p&gt;As established, &lt;code&gt;head&lt;/code&gt; is partial because there is no element to return if the list is empty: we’ve made a promise we cannot possibly fulfill. Fortunately, there’s an easy solution to that dilemma: we can weaken our promise. Since we cannot guarantee the caller an element of the list, we’ll have to practice a little expectation management: we’ll do our best return an element if we can, but we reserve the right to return nothing at all. In Haskell, we express this possibility using the &lt;code&gt;Maybe&lt;/code&gt; type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This buys us the freedom we need to implement &lt;code&gt;head&lt;/code&gt;—it allows us to return &lt;code&gt;Nothing&lt;/code&gt; when we discover we can’t produce a value of type &lt;code&gt;a&lt;/code&gt; after all:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt;    &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Problem solved, right? For the moment, yes… but this solution has a hidden cost.&lt;/p&gt;

&lt;p&gt;Returning &lt;code&gt;Maybe&lt;/code&gt; is undoubtably convenient when we’re &lt;em&gt;implementing&lt;/em&gt; &lt;code&gt;head&lt;/code&gt;. However, it becomes significantly less convenient when we want to actually use it! Since &lt;code&gt;head&lt;/code&gt; always has the potential to return &lt;code&gt;Nothing&lt;/code&gt;, the burden falls upon its callers to handle that possibility, and sometimes that passing of the buck can be incredibly frustrating. To see why, consider the following code:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirsString&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getEnv&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS"&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;configDirsString&lt;/span&gt;
  &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;
    &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS cannot be empty"&lt;/span&gt;
  &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getConfigurationDirectories&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;cacheDir&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;initializeCache&lt;/span&gt; &lt;span class="n"&gt;cacheDir&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"should never happen; already checked configDirs is non-empty"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;When &lt;code&gt;getConfigurationDirectories&lt;/code&gt; retrieves a list of file paths from the environment, it proactively checks that the list is non-empty. However, when we use &lt;code&gt;head&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt; to get the first element of the list, the &lt;code&gt;Maybe FilePath&lt;/code&gt; result still requires us to handle a &lt;code&gt;Nothing&lt;/code&gt; case that we know will never happen! This is terribly bad for several reasons:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;First, it’s just annoying. We already checked that the list is non-empty, why do we have to clutter our code with another redundant check?&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Second, it has a potential performance cost. Although the cost of the redundant check is trivial in this particular example, one could imagine a more complex scenario where the redundant checks could add up, such as if they were happening in a tight loop.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Finally, and worst of all, this code is a bug waiting to happen! What if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; were modified to stop checking that the list is empty, intentionally or unintentionally? The programmer might not remember to update &lt;code&gt;main&lt;/code&gt;, and suddenly the “impossible” error becomes not only possible, but probable.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The need for this redundant check has essentially forced us to punch a hole in our type system. If we could statically &lt;em&gt;prove&lt;/em&gt; the &lt;code&gt;Nothing&lt;/code&gt; case impossible, then a modification to &lt;code&gt;getConfigurationDirectories&lt;/code&gt; that stopped checking if the list was empty would invalidate the proof and trigger a compile-time failure. However, as-written, we’re forced to rely on a test suite or manual inspection to catch the bug.&lt;/p&gt;

&lt;h3 id="paying-it-forward"&gt;Paying it forward&lt;/h3&gt;

&lt;p&gt;Clearly, our modified version of &lt;code&gt;head&lt;/code&gt; leaves some things to be desired. Somehow, we’d like it to be smarter: if we already checked that the list was non-empty, &lt;code&gt;head&lt;/code&gt; should unconditionally return the first element without forcing us to handle the case we know is impossible. How can we do that?&lt;/p&gt;

&lt;p&gt;Let’s look at the original (partial) type signature for &lt;code&gt;head&lt;/code&gt; again:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The previous section illustrated that we can turn that partial type signature into a total one by weakening the promise made in the return type. However, since we don’t want to do that, there’s only one thing left that can be changed: the argument type (in this case, &lt;code&gt;[a]&lt;/code&gt;). Instead of weakening the return type, we can &lt;em&gt;strengthen&lt;/em&gt; the argument type, eliminating the possibility of &lt;code&gt;head&lt;/code&gt; ever being called on an empty list in the first place.&lt;/p&gt;

&lt;p&gt;To do this, we need a type that represents non-empty lists. Fortunately, the existing &lt;code&gt;NonEmpty&lt;/code&gt; type from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; is exactly that. It has the following definition:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;:|&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that &lt;code&gt;NonEmpty a&lt;/code&gt; is really just a tuple of an &lt;code&gt;a&lt;/code&gt; and an ordinary, possibly-empty &lt;code&gt;[a]&lt;/code&gt;. This conveniently models a non-empty list by storing the first element of the list separately from the list’s tail: even if the &lt;code&gt;[a]&lt;/code&gt; component is &lt;code&gt;[]&lt;/code&gt;, the &lt;code&gt;a&lt;/code&gt; component must always be present. This makes &lt;code&gt;head&lt;/code&gt; completely trivial to implement:&lt;sup&gt;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-2-definition" name="2019-11-05-parse-don-t-validate-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:|&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Unlike before, GHC accepts this definition without complaint—this definition is &lt;em&gt;total&lt;/em&gt;, not partial. We can update our program to use the new implementation:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="kt"&gt;FilePath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;getConfigurationDirectories&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirsString&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getEnv&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS"&lt;/span&gt;
  &lt;span class="kr"&gt;let&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;split&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;configDirsString&lt;/span&gt;
  &lt;span class="kr"&gt;case&lt;/span&gt; &lt;span class="n"&gt;nonEmpty&lt;/span&gt; &lt;span class="n"&gt;configDirsList&lt;/span&gt; &lt;span class="kr"&gt;of&lt;/span&gt;
    &lt;span class="kt"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;nonEmptyConfigDirsList&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="n"&gt;nonEmptyConfigDirsList&lt;/span&gt;
    &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"CONFIG_DIRS cannot be empty"&lt;/span&gt;

&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;do&lt;/span&gt;
  &lt;span class="n"&gt;configDirs&lt;/span&gt; &lt;span class="ow"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;getConfigurationDirectories&lt;/span&gt;
  &lt;span class="n"&gt;initializeCache&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="n"&gt;configDirs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that the redundant check in &lt;code&gt;main&lt;/code&gt; is now completely gone! Instead, we perform the check exactly once, in &lt;code&gt;getConfigurationDirectories&lt;/code&gt;. It constructs a &lt;code&gt;NonEmpty a&lt;/code&gt; from a &lt;code&gt;[a]&lt;/code&gt; using the &lt;code&gt;nonEmpty&lt;/code&gt; function from &lt;code&gt;Data.List.NonEmpty&lt;/code&gt;, which has the following type:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;nonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;Maybe&lt;/code&gt; is still there, but this time, we handle the &lt;code&gt;Nothing&lt;/code&gt; case very early in our program: right in the same place we were already doing the input validation. Once that check has passed, we now have a &lt;code&gt;NonEmpty FilePath&lt;/code&gt; value, which preserves (in the type system!) the knowledge that the list really is non-empty. Put another way, you can think of a value of type &lt;code&gt;NonEmpty a&lt;/code&gt; as being like a value of type &lt;code&gt;[a]&lt;/code&gt;, plus a &lt;em&gt;proof&lt;/em&gt; that the list is non-empty.&lt;/p&gt;

&lt;p&gt;By strengthening the type of the argument to &lt;code&gt;head&lt;/code&gt; instead of weakening the type of its result, we’ve completely eliminated all the problems from the previous section:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The code has no redundant checks, so there can’t be any performance overhead.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Furthermore, if &lt;code&gt;getConfigurationDirectories&lt;/code&gt; changes to stop checking that the list is non-empty, its return type must change, too. Consequently, &lt;code&gt;main&lt;/code&gt; will fail to typecheck, alerting us to the problem before we even run the program!&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;What’s more, it’s trivial to recover the old behavior of &lt;code&gt;head&lt;/code&gt; from the new one by composing &lt;code&gt;head&lt;/code&gt; with &lt;code&gt;nonEmpty&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;head&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="nf"&gt;head&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fmap&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;nonEmpty&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that the inverse is &lt;em&gt;not&lt;/em&gt; true: there is no way to obtain the new version of &lt;code&gt;head&lt;/code&gt; from the old one. All in all, the second approach is superior on all axes.&lt;/p&gt;

&lt;h2 id="the-power-of-parsing"&gt;The power of parsing&lt;/h2&gt;

&lt;p&gt;You may be wondering what the above example has to do with the title of this blog post. After all, we only examined two different ways to validate that a list was non-empty—no parsing in sight. That interpretation isn’t wrong, but I’d like to propose another perspective: in my mind, the difference between validation and parsing lies almost entirely in how information is preserved. Consider the following pair of functions:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="kr"&gt;_&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;span class="nf"&gt;validateNonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"list cannot be empty"&lt;/span&gt;

&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;IO&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;NonEmpty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pure&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="kt"&gt;:|&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nf"&gt;parseNonEmpty&lt;/span&gt; &lt;span class="kt"&gt;[]&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="n"&gt;throwIO&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt; &lt;span class="n"&gt;userError&lt;/span&gt; &lt;span class="s"&gt;"list cannot be empty"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;These two functions are nearly identical: they check if the provided list is empty, and if it is, they abort the program with an error message. The difference lies entirely in the return type: &lt;code&gt;validateNonEmpty&lt;/code&gt; always returns &lt;code&gt;()&lt;/code&gt;, the type that contains no information, but &lt;code&gt;parseNonEmpty&lt;/code&gt; returns &lt;code&gt;NonEmpty a&lt;/code&gt;, a refinement of the input type that preserves the knowledge gained in the type system. Both of these functions check the same thing, but &lt;code&gt;parseNonEmpty&lt;/code&gt; gives the caller access to the information it learned, while &lt;code&gt;validateNonEmpty&lt;/code&gt; just throws it away.&lt;/p&gt;

&lt;p&gt;These two functions elegantly illustrate two different perspectives on the role of a static type system: &lt;code&gt;validateNonEmpty&lt;/code&gt; obeys the typechecker well enough, but only &lt;code&gt;parseNonEmpty&lt;/code&gt; takes full advantage of it. If you see why &lt;code&gt;parseNonEmpty&lt;/code&gt; is preferable, you understand what I mean by the mantra “parse, don’t validate.” Still, perhaps you are skeptical of &lt;code&gt;parseNonEmpty&lt;/code&gt;’s name. Is it really &lt;em&gt;parsing&lt;/em&gt; anything, or is it merely validating its input and returning a result? While the precise definition of what it means to parse or validate something is debatable, I believe &lt;code&gt;parseNonEmpty&lt;/code&gt; is a bona-fide parser (albeit a particularly simple one).&lt;/p&gt;

&lt;p&gt;Consider: what is a parser? Really, a parser is just a function that consumes less-structured input and produces more-structured output. By its very nature, a parser is a partial function—some values in the domain do not correspond to any value in the range—so all parsers must have some notion of failure. Often, the input to a parser is text, but this is by no means a requirement, and &lt;code&gt;parseNonEmpty&lt;/code&gt; is a perfectly cromulent parser: it parses lists into non-empty lists, signaling failure by terminating the program with an error message.&lt;/p&gt;

&lt;p&gt;Under this flexible definition, parsers are an incredibly powerful tool: they allow discharging checks on input up-front, right on the boundary between a program and the outside world, and once those checks have been performed, they never need to be checked again! Haskellers are well-aware of this power, and they use many different types of parsers on a regular basis:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/aeson"&gt;aeson&lt;/a&gt; library provides a &lt;code&gt;Parser&lt;/code&gt; type that can be used to parse JSON data into domain types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Likewise, &lt;a href="https://hackage.haskell.org/package/optparse-applicative"&gt;optparse-applicative&lt;/a&gt; provides a set of parser combinators for parsing command-line arguments.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Database libraries like &lt;a href="https://hackage.haskell.org/package/persistent"&gt;persistent&lt;/a&gt; and &lt;a href="https://hackage.haskell.org/package/postgresql-simple"&gt;postgresql-simple&lt;/a&gt; have a mechanism for parsing values held in an external data store.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The &lt;a href="https://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; ecosystem is built around parsing Haskell datatypes from path components, query parameters, HTTP headers, and more.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The common theme between all these libraries is that they sit on the boundary between your Haskell application and the external world. That world doesn’t speak in product and sum types, but in streams of bytes, so there’s no getting around a need to do some parsing. Doing that parsing up front, before acting on the data, can go a long way toward avoiding many classes of bugs, some of which might even be security vulnerabilities.&lt;/p&gt;

&lt;p&gt;One drawback to this approach of parsing everything up front is that it sometimes requires values be parsed long before they are actually used. In a dynamically-typed language, this can make keeping the parsing and processing logic in sync a little tricky without extensive test coverage, much of which can be laborious to maintain. However, with a static type system, the problem becomes marvelously simple, as demonstrated by the &lt;code&gt;NonEmpty&lt;/code&gt; example above: if the parsing and processing logic go out of sync, the program will fail to even compile.&lt;/p&gt;

&lt;h2 id="the-danger-of-validation"&gt;The danger of validation&lt;/h2&gt;

&lt;p&gt;Hopefully, by this point, you are at least somewhat sold on the idea that parsing is preferable to validation, but you may have lingering doubts. Is validation really so bad if the type system is going to force you to do the necessary checks eventually anyway? Maybe the error reporting will be a little bit worse, but a bit of redundant checking can’t hurt, right?&lt;/p&gt;

&lt;p&gt;Unfortunately, it isn’t so simple. Ad-hoc validation leads to a phenomenon that the &lt;a href="http://langsec.org"&gt;language-theoretic security&lt;/a&gt; field calls &lt;em&gt;shotgun parsing&lt;/em&gt;. In the 2016 paper, &lt;a href="http://langsec.org/papers/langsec-cwes-secdev2016.pdf"&gt;The Seven Turrets of Babel: A Taxonomy of LangSec Errors and How to Expunge Them&lt;/a&gt;, its authors provide the following definition:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Shotgun parsing is a programming antipattern whereby parsing and input-validating code is mixed with and spread across processing code—throwing a cloud of checks at the input, and hoping, without any systematic justification, that one or another would catch all the “bad” cases.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;They go on to explain the problems inherent to such validation techniques:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Shotgun parsing necessarily deprives the program of the ability to reject invalid input instead of processing it. Late-discovered errors in an input stream will result in some portion of invalid input having been processed, with the consequence that program state is difficult to accurately predict.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In other words, a program that does not parse all of its input up front runs the risk of acting upon a valid portion of the input, discovering a different portion is invalid, and suddenly needing to roll back whatever modifications it already executed in order to maintain consistency. Sometimes this is possible—such as rolling back a transaction in an RDBMS—but in general it may not be.&lt;/p&gt;

&lt;p&gt;It may not be immediately apparent what shotgun parsing has to do with validation—after all, if you do all your validation up front, you mitigate the risk of shotgun parsing. The problem is that validation-based approaches make it extremely difficult or impossible to determine if everything was actually validated up front or if some of those so-called “impossible” cases might actually happen. The entire program must assume that raising an exception anywhere is not only possible, it’s regularly necessary.&lt;/p&gt;

&lt;p&gt;Parsing avoids this problem by stratifying the program into two phases—parsing and execution—where failure due to invalid input can only happen in the first phase. The set of remaining failure modes during execution is minimal by comparison, and they can be handled with the tender care they require.&lt;/p&gt;

&lt;h1 id="parsing-not-validating-in-practice"&gt;Parsing, not validating, in practice&lt;/h1&gt;

&lt;p&gt;So far, this blog post has been something of a sales pitch. “You, dear reader, ought to be parsing!” it says, and if I’ve done my job properly, at least some of you are sold. However, even if you understand the “what” and the “why,” you might not feel especially confident about the “how.”&lt;/p&gt;

&lt;p&gt;My advice: focus on the datatypes.&lt;/p&gt;

&lt;p&gt;Suppose you are writing a function that accepts a list of tuples representing key-value pairs, and you suddenly realize you aren’t sure what to do if the list has duplicate keys. One solution would be to write a function that asserts there aren’t any duplicates in the list:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;checkNoDuplicateKeys&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="kt"&gt;AppError&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="nb"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, this check is fragile: it’s extremely easy to forget. Because its return value is unused, it can always be omitted, and the code that needs it would still typecheck. A better solution is to choose a data structure that disallows duplicate keys by construction, such as a &lt;code&gt;Map&lt;/code&gt;. Adjust your function’s type signature to accept a &lt;code&gt;Map&lt;/code&gt; instead of a list of tuples, and implement it as you normally would.&lt;/p&gt;

&lt;p&gt;Once you’ve done that, the call site of your new function will likely fail to typecheck, since it is still being passed a list of tuples. If the caller was given the value via one of its arguments, or if it received it from the result of some other function, you can continue updating the type from list to &lt;code&gt;Map&lt;/code&gt;, all the way up the call chain. Eventually, you will either reach the location the value is created, or you’ll find a place where duplicates actually ought to be allowed. At that point, you can insert a call to a modified version of &lt;code&gt;checkNoDuplicateKeys&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;checkNoDuplicateKeys&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;MonadError&lt;/span&gt; &lt;span class="kt"&gt;AppError&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;Eq&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now the check &lt;em&gt;cannot&lt;/em&gt; be omitted, since its result is actually necessary for the program to proceed!&lt;/p&gt;

&lt;p&gt;This hypothetical scenario highlights two simple ideas:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Use a data structure that makes illegal states unrepresentable.&lt;/strong&gt; Model your data using the most precise data structure you reasonably can. If ruling out a particular possibility is too hard using the encoding you are currently using, consider alternate encodings that can express the property you care about more easily. Don’t be afraid to refactor.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Push the burden of proof upward as far as possible, but no further.&lt;/strong&gt; Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before &lt;em&gt;any&lt;/em&gt; of the data is acted upon.&lt;sup&gt;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-3-definition" name="2019-11-05-parse-don-t-validate-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
  &lt;p&gt; If one particular code branch eventually requires a more precise representation of a piece of data, parse the data into the more precise representation as soon as the branch is selected. Use sum types judiciously to allow your datatypes to reflect and adapt to control flow.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;In other words, write functions on the data representation you &lt;em&gt;wish&lt;/em&gt; you had, not the data representation you are given. The design process then becomes an exercise in bridging the gap, often by working from both ends until they meet somewhere in the middle. Don’t be afraid to iteratively adjust parts of the design as you go, since you may learn something new during the refactoring process!&lt;/p&gt;

&lt;p&gt;Here are a handful of additional points of advice, arranged in no particular order:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Let your datatypes inform your code, don’t let your code control your datatypes.&lt;/strong&gt; Avoid the temptation to just stick a &lt;code&gt;Bool&lt;/code&gt; in a record somewhere because it’s needed by the function you’re currently writing. Don’t be afraid to refactor code to use the right data representation—the type system will ensure you’ve covered all the places that need changing, and it will likely save you a headache later.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Treat functions that return &lt;code&gt;m ()&lt;/code&gt; with deep suspicion.&lt;/strong&gt; Sometimes these are genuinely necessary, as they may perform an imperative effect with no meaningful result, but if the primary purpose of that effect is raising an error, it’s likely there’s a better way.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Don’t be afraid to parse data in multiple passes.&lt;/strong&gt; Avoiding shotgun parsing just means you shouldn’t act on the input data before it’s fully parsed, not that you can’t use some of the input data to decide how to parse other input data. Plenty of useful parsers are context-sensitive.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Avoid denormalized representations of data, &lt;em&gt;especially&lt;/em&gt; if it’s mutable.&lt;/strong&gt; Duplicating the same data in multiple places introduces a trivially representable illegal state: the places getting out of sync. Strive for a single source of truth.&lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;&lt;strong&gt;Keep denormalized representations of data behind abstraction boundaries.&lt;/strong&gt; If denormalization is absolutely necessary, use encapsulation to ensure a small, trusted module holds sole responsibility for keeping the representations in sync.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
 &lt;li&gt;&lt;strong&gt;Use abstract datatypes to make validators “look like” parsers.&lt;/strong&gt; Sometimes, making an illegal state truly unrepresentable is just plain impractical given the tools Haskell provides, such as ensuring an integer is in a particular range. In that case, use an abstract &lt;code&gt;newtype&lt;/code&gt; with a smart constructor to “fake” a parser from a validator.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;As always, use your best judgement. It probably isn’t worth breaking out &lt;a href="https://hackage.haskell.org/package/singletons"&gt;singletons&lt;/a&gt; and refactoring your entire application just to get rid of a single &lt;code&gt;error "impossible"&lt;/code&gt; call somewhere—just make sure to treat those situations like the radioactive substance they are, and handle them with the appropriate care. If all else fails, at least leave a comment to document the invariant for whoever needs to modify the code next.&lt;/p&gt;

&lt;h1 id="recap-reflection-and-related-reading"&gt;Recap, reflection, and related reading&lt;/h1&gt;

&lt;p&gt;That’s all, really. Hopefully this blog post proves that taking advantage of the Haskell type system doesn’t require a PhD, and it doesn’t even require using the latest and greatest of GHC’s shiny new language extensions—though they can certainly sometimes help! Sometimes the biggest obstacle to using Haskell to its fullest is simply being aware what options are available, and unfortunately, one downside of Haskell’s small community is a relative dearth of resources that document design patterns and techniques that have become tribal knowledge.&lt;/p&gt;

&lt;p&gt;None of the ideas in this blog post are new. In fact, the core idea—“write total functions”—is conceptually quite simple. Despite that, I find it remarkably challenging to communicate actionable, practicable details about the way I write Haskell code. It’s easy to spend lots of time talking about abstract concepts—many of which are quite valuable!—without communicating anything useful about &lt;em&gt;process&lt;/em&gt;. My hope is that this is a small step in that direction.&lt;/p&gt;

&lt;p&gt;Sadly, I don’t know very many other resources on this particular topic, but I do know of one: I never hesitate to recommend Matt Parson’s fantastic blog post &lt;a href="https://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html"&gt;Type Safety Back and Forth&lt;/a&gt;. If you want another accessible perspective on these ideas, including another worked example, I’d highly encourage giving it a read. For a significantly more advanced take on many of these ideas, I can also recommend Matt Noonan’s 2018 paper &lt;a href="https://kataskeue.com/gdp.pdf"&gt;Ghosts of Departed Proofs&lt;/a&gt;, which outlines a handful of techniques for capturing more complex invariants in the type system than I have described here.&lt;/p&gt;

&lt;p&gt;As a closing note, I want to say that doing the kind of refactoring described in this blog post is not always easy. The examples I’ve given are simple, but real life is often much less straightforward. Even for those experienced in type-driven design, it can be genuinely difficult to capture certain invariants in the type system, so do not consider it a personal failing if you cannot solve something the way you’d like! Consider the principles in this blog post ideals to strive for, not strict requirements to meet. All that matters is to try.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2019-11-05-parse-don-t-validate-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Technically, in Haskell, this ignores “bottoms,” constructions that can inhabit &lt;em&gt;any&lt;/em&gt; value. These aren’t “real” values (unlike &lt;code&gt;null&lt;/code&gt; in some other languages)—they’re things like infinite loops or computations that raise exceptions—and in idiomatic Haskell, we usually try to avoid them, so reasoning that pretends they don’t exist still has value. But don’t take my word for it—I’ll let Danielsson et al. convince you that &lt;a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf"&gt;Fast and Loose Reasoning is Morally Correct&lt;/a&gt;.&amp;nbsp;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-11-05-parse-don-t-validate-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;In fact, &lt;code&gt;Data.List.NonEmpty&lt;/code&gt; already provides a &lt;code&gt;head&lt;/code&gt; function with this type, but just for the sake of illustration, we’ll reimplement it ourselves.&amp;nbsp;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2019-11-05-parse-don-t-validate-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;Sometimes it is necessary to perform some kind of authorization before parsing user input to avoid denial of service attacks, but that’s okay: authorization should have a relatively small surface area, and it shouldn’t cause any significant modifications to the state of your system.&amp;nbsp;&lt;a href="#2019-11-05-parse-don-t-validate-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item></channel></rss>